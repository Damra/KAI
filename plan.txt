# ğŸ—ï¸ Kotlin/KTOR GeliÅŸtirici AsistanÄ± â€” Ajan Mimarisi TasarÄ±mÄ±

## Genel BakÄ±ÅŸ

Bu dokÃ¼man, **kod Ã¼retimi / geliÅŸtirici asistanÄ±** amacÄ±yla KTOR backend Ã¼zerinde Ã§alÄ±ÅŸacak bir AI ajan sisteminin mimari tasarÄ±mÄ±nÄ± sunar. DÃ¶rt temel pattern birleÅŸtirilmiÅŸtir:

| Pattern | RolÃ¼ | Kotlin KarÅŸÄ±lÄ±ÄŸÄ± |
|---------|-------|-------------------|
| **ReAct** | DÃ¼ÅŸÃ¼n â†’ AraÃ§ Kullan â†’ GÃ¶zlemle â†’ Tekrarla | Coroutine-based state machine + sealed class |
| **Multi-Agent** | Uzman ajanlarÄ±n iÅŸ bÃ¶lÃ¼mÃ¼ | KTOR Actor pattern + Channel iletiÅŸimi |
| **Memory** | Episodic + Semantic hafÄ±za | PostgreSQL (pgvector) + Neo4j |
| **PEV** | Planla â†’ Uygula â†’ DoÄŸrula | Pipeline pattern + verification gate |

---

## 1. Ãœst DÃ¼zey Mimari

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      KTOR Backend                           â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ WebSocketâ”‚â”€â”€â”€â–¶â”‚ Meta-Controllerâ”‚â”€â”€â”€â–¶â”‚  Agent Router   â”‚   â”‚
â”‚  â”‚ /REST APIâ”‚    â”‚  (Orchestrator)â”‚    â”‚                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                      â”‚             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚         â–¼               â–¼                      â–¼      â–¼      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Planner  â”‚  â”‚ CodeWriter â”‚  â”‚ Reviewer  â”‚  â”‚ Fixer  â”‚   â”‚
â”‚   â”‚  Agent   â”‚  â”‚   Agent    â”‚  â”‚  Agent    â”‚  â”‚ Agent  â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚               â”‚              â”‚           â”‚         â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                         â”‚                                    â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚              â–¼                     â–¼                         â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚     â”‚   Tool Layer  â”‚     â”‚ Memory Layer â”‚                   â”‚
â”‚     â”‚ â”€ Compiler    â”‚     â”‚ â”€ Episodic   â”‚                   â”‚
â”‚     â”‚ â”€ Linter      â”‚     â”‚   (pgvector) â”‚                   â”‚
â”‚     â”‚ â”€ Test Runner â”‚     â”‚ â”€ Semantic   â”‚                   â”‚
â”‚     â”‚ â”€ File I/O    â”‚     â”‚   (Neo4j)    â”‚                   â”‚
â”‚     â”‚ â”€ Web Search  â”‚     â”‚ â”€ Session    â”‚                   â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Temel Veri Modelleri (Kotlin Sealed Classes)

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Core State Machine - TÃ¼m ajanlarÄ±n ortak dili
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Bir ajan dÃ¶ngÃ¼sÃ¼ndeki olasÄ± adÄ±mlar.
 * Sealed class sayesinde `when` bloÄŸu exhaustive olur â€” 
 * yeni bir adÄ±m eklediÄŸinde compiler seni uyarÄ±r.
 */
sealed class AgentStep {
    /** LLM dÃ¼ÅŸÃ¼nÃ¼yor, reasoning Ã¼retiyor */
    data class Think(
        val thought: String,
        val confidence: Double = 0.0  // 0.0 - 1.0
    ) : AgentStep()
    
    /** Bir araÃ§ Ã§aÄŸrÄ±lacak */
    data class Act(
        val toolName: String,
        val toolInput: Map<String, Any>,
        val reasoning: String  // Neden bu aracÄ± seÃ§ti
    ) : AgentStep()
    
    /** AraÃ§ sonucu geri dÃ¶ndÃ¼ */
    data class Observe(
        val toolName: String,
        val result: ToolResult,
        val durationMs: Long
    ) : AgentStep()
    
    /** SonuÃ§ hazÄ±r, dÃ¶ngÃ¼ bitti */
    data class Answer(
        val content: String,
        val artifacts: List<CodeArtifact> = emptyList(),
        val metadata: AnswerMetadata? = null
    ) : AgentStep()
    
    /** Hata oluÅŸtu, recovery gerekiyor */
    data class Error(
        val message: String,
        val recoverable: Boolean,
        val suggestedAction: String? = null
    ) : AgentStep()
    
    /** BaÅŸka bir ajana devret */
    data class Delegate(
        val targetAgent: AgentRole,
        val context: DelegationContext
    ) : AgentStep()
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Agent Rolleri
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum class AgentRole {
    PLANNER,       // GÃ¶revi alt gÃ¶revlere bÃ¶ler
    CODE_WRITER,   // Kod Ã¼retir
    REVIEWER,      // Kodu inceler, hata bulur
    FIXER,         // HatalarÄ± dÃ¼zeltir
    TESTER,        // Test yazar ve Ã§alÄ±ÅŸtÄ±rÄ±r
    RESEARCHER     // DokÃ¼mantasyon / API araÅŸtÄ±rÄ±r
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Tool System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sealed class ToolResult {
    data class Success(val output: String, val data: Any? = null) : ToolResult()
    data class Failure(val error: String, val retryable: Boolean) : ToolResult()
}

data class CodeArtifact(
    val filename: String,
    val language: String,
    val content: String,
    val version: Int = 1
)

data class AnswerMetadata(
    val totalSteps: Int,
    val toolsUsed: List<String>,
    val totalDurationMs: Long,
    val agentsInvolved: List<AgentRole>
)
```

---

## 3. ReAct DÃ¶ngÃ¼sÃ¼ â€” Tek Ajan Ã‡ekirdeÄŸi

Her ajan, ReAct pattern'ini temel alÄ±r. Bu, tÃ¼m sistemin **atom birimi**dir.

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ReAct Loop - Her ajanÄ±n kalbi
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ReActAgent(
    private val role: AgentRole,
    private val llmClient: LLMClient,
    private val tools: Map<String, Tool>,
    private val memory: MemoryLayer,
    private val config: AgentConfig = AgentConfig()
) {
    data class AgentConfig(
        val maxIterations: Int = 10,
        val maxRetries: Int = 3,
        val thinkingBudget: Int = 5,     // KaÃ§ "dÃ¼ÅŸÃ¼nme" adÄ±mÄ±
        val confidenceThreshold: Double = 0.7
    )
    
    /**
     * Ana Ã§alÄ±ÅŸtÄ±rma dÃ¶ngÃ¼sÃ¼. 
     * suspend fun olmasÄ± sayesinde her adÄ±m non-blocking.
     */
    suspend fun execute(task: AgentTask): AgentStep.Answer {
        val trajectory = mutableListOf<AgentStep>()
        var iteration = 0
        
        // 1) HafÄ±zadan ilgili baÄŸlamÄ± Ã§ek
        val episodicContext = memory.recallSimilar(task.description, limit = 5)
        val semanticContext = memory.queryGraph(task.entities())
        
        // 2) Sistem promptunu oluÅŸtur (role-specific)
        val systemPrompt = buildSystemPrompt(role, episodicContext, semanticContext)
        
        while (iteration < config.maxIterations) {
            iteration++
            
            // 3) LLM'e mevcut trajectory'yi gÃ¶nder â†’ sonraki adÄ±mÄ± al
            val nextStep = llmClient.reason(
                system = systemPrompt,
                trajectory = trajectory,
                availableTools = tools.keys.toList()
            )
            
            trajectory.add(nextStep)
            
            when (nextStep) {
                is AgentStep.Think -> {
                    // DÃ¼ÅŸÃ¼nce kaydedildi, dÃ¶ngÃ¼ devam
                    continue
                }
                
                is AgentStep.Act -> {
                    // AracÄ± Ã§alÄ±ÅŸtÄ±r
                    val tool = tools[nextStep.toolName]
                        ?: throw AgentException("Unknown tool: ${nextStep.toolName}")
                    
                    val result = withTimeoutOrNull(30_000) {
                        tool.execute(nextStep.toolInput)
                    } ?: ToolResult.Failure("Tool timeout after 30s", retryable = true)
                    
                    val observe = AgentStep.Observe(
                        toolName = nextStep.toolName,
                        result = result,
                        durationMs = measureTimeMillis { /* already measured */ }
                    )
                    trajectory.add(observe)
                }
                
                is AgentStep.Answer -> {
                    // Episodic hafÄ±zaya kaydet
                    memory.storeEpisode(
                        task = task,
                        trajectory = trajectory,
                        outcome = nextStep
                    )
                    return nextStep
                }
                
                is AgentStep.Delegate -> {
                    // Bu adÄ±m Multi-Agent katmanÄ±nda yakalanÄ±r
                    throw DelegationException(nextStep)
                }
                
                is AgentStep.Error -> {
                    if (!nextStep.recoverable) throw AgentException(nextStep.message)
                    // Recoverable â†’ trajectory'ye ekle, LLM recovery denesin
                    continue
                }
                
                is AgentStep.Observe -> {
                    // LLM doÄŸrudan Observe Ã¼retmez, Act sonrasÄ± biz ekleriz
                    continue
                }
            }
        }
        
        throw AgentException("Max iterations ($config.maxIterations) exceeded")
    }
}
```

---

## 4. Multi-Agent Orkestrasyon

Meta-Controller, gelen gÃ¶revi analiz edip doÄŸru ajanlara yÃ¶nlendirir.

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Multi-Agent Orchestrator
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MetaController(
    private val agents: Map<AgentRole, ReActAgent>,
    private val llmClient: LLMClient,
    private val memory: MemoryLayer
) {
    /**
     * KullanÄ±cÄ± isteÄŸini alÄ±r â†’ Plan oluÅŸturur â†’ 
     * AjanlarÄ± sÄ±rayla/paralel Ã§alÄ±ÅŸtÄ±rÄ±r â†’ SonuÃ§ dÃ¶ner
     */
    suspend fun process(userRequest: String, sessionId: String): AgentResponse {
        
        // â•â•â• ADIM 1: PLANLAMA â•â•â•
        val plan = planTask(userRequest)
        
        // â•â•â• ADIM 2: YÃœRÃœTME â•â•â•
        val results = mutableMapOf<String, AgentStep.Answer>()
        
        for (step in plan.steps) {
            val agent = agents[step.assignedAgent]
                ?: throw IllegalStateException("No agent for role: ${step.assignedAgent}")
            
            val task = AgentTask(
                description = step.description,
                context = buildContext(results, step.dependsOn),
                constraints = step.constraints
            )
            
            try {
                val result = agent.execute(task)
                results[step.id] = result
                
                // â•â•â• ADIM 3: DOÄRULAMA (PEV) â•â•â•
                if (step.requiresVerification) {
                    val verification = verify(step, result)
                    if (!verification.passed) {
                        // Retry veya Fixer'a gÃ¶nder
                        val fixed = handleVerificationFailure(step, result, verification)
                        results[step.id] = fixed
                    }
                }
            } catch (e: DelegationException) {
                // Ajan baÅŸka bir ajana devretmek istiyor
                val delegatedResult = agents[e.delegation.targetAgent]
                    ?.execute(AgentTask.fromDelegation(e.delegation))
                    ?: throw AgentException("Delegation target not found")
                results[step.id] = delegatedResult
            }
        }
        
        // â•â•â• ADIM 4: SONUÃ‡ BÄ°RLEÅTÄ°RME â•â•â•
        return synthesizeResults(plan, results)
    }
    
    /**
     * LLM kullanarak gÃ¶revi alt adÄ±mlara bÃ¶ler.
     * Her adÄ±m hangi ajana gideceÄŸini ve baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± belirtir.
     */
    private suspend fun planTask(request: String): ExecutionPlan {
        val planResponse = llmClient.chat(
            system = PLANNER_SYSTEM_PROMPT,
            user = """
                KullanÄ±cÄ± Ä°steÄŸi: $request
                
                Mevcut Ajanlar: ${agents.keys.joinToString()}
                
                JSON formatÄ±nda bir yÃ¼rÃ¼tme planÄ± oluÅŸtur:
                {
                  "steps": [
                    {
                      "id": "step_1",
                      "description": "...",
                      "assignedAgent": "CODE_WRITER",
                      "dependsOn": [],
                      "requiresVerification": true,
                      "constraints": ["Kotlin", "coroutines"]
                    }
                  ]
                }
            """.trimIndent()
        )
        return Json.decodeFromString<ExecutionPlan>(planResponse)
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Execution Plan modeli
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@Serializable
data class ExecutionPlan(
    val steps: List<PlanStep>
)

@Serializable
data class PlanStep(
    val id: String,
    val description: String,
    val assignedAgent: AgentRole,
    val dependsOn: List<String> = emptyList(),
    val requiresVerification: Boolean = true,
    val constraints: List<String> = emptyList()
)
```

---

## 5. PEV â€” Plan, Execute, Verify DÃ¶ngÃ¼sÃ¼

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Verification Gate
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class VerificationGate(
    private val llmClient: LLMClient,
    private val tools: VerificationTools
) {
    data class VerificationResult(
        val passed: Boolean,
        val score: Double,          // 0.0 - 1.0
        val issues: List<Issue>,
        val suggestions: List<String>
    )
    
    data class Issue(
        val severity: Severity,     // CRITICAL, WARNING, INFO
        val description: String,
        val location: String?       // dosya:satÄ±r
    )
    
    enum class Severity { CRITICAL, WARNING, INFO }
    
    /**
     * Ãœretilen kodu Ã§ok katmanlÄ± olarak doÄŸrular:
     * 1) Statik analiz (lint, compile check)
     * 2) MantÄ±ksal doÄŸruluk (LLM-as-Judge)
     * 3) Test Ã§alÄ±ÅŸtÄ±rma (varsa)
     */
    suspend fun verify(step: PlanStep, result: AgentStep.Answer): VerificationResult {
        val issues = mutableListOf<Issue>()
        
        // â”€â”€ Katman 1: Statik Analiz â”€â”€
        for (artifact in result.artifacts) {
            when (artifact.language.lowercase()) {
                "kotlin" -> {
                    val lintResult = tools.kotlinLint(artifact.content)
                    issues.addAll(lintResult.issues)
                    
                    val compileResult = tools.kotlinCompileCheck(artifact.content)
                    if (!compileResult.success) {
                        issues.add(Issue(
                            Severity.CRITICAL,
                            "Derleme hatasÄ±: ${compileResult.error}",
                            artifact.filename
                        ))
                    }
                }
                "java" -> {
                    val lintResult = tools.javaLint(artifact.content)
                    issues.addAll(lintResult.issues)
                }
            }
        }
        
        // â”€â”€ Katman 2: LLM-as-Judge â”€â”€
        val judgeScore = llmClient.chat(
            system = """
                Sen bir kod review uzmanÄ±sÄ±n. Verilen kodu ÅŸu kriterlere gÃ¶re puanla:
                1. DoÄŸruluk (gÃ¶revi yerine getiriyor mu?)
                2. Kotlin idiomatik kullanÄ±m
                3. Hata yÃ¶netimi
                4. Performans
                
                JSON dÃ¶ndÃ¼r: { "score": 0.0-1.0, "issues": [...], "suggestions": [...] }
            """.trimIndent(),
            user = """
                GÃ¶rev: ${step.description}
                KÄ±sÄ±tlar: ${step.constraints}
                Ãœretilen Kod:
                ${result.artifacts.joinToString("\n---\n") { it.content }}
            """.trimIndent()
        )
        
        val judgeResult = Json.decodeFromString<JudgeResponse>(judgeScore)
        issues.addAll(judgeResult.issues.map { 
            Issue(Severity.WARNING, it, null) 
        })
        
        // â”€â”€ Katman 3: Test Ã‡alÄ±ÅŸtÄ±rma â”€â”€
        val testArtifacts = result.artifacts.filter { it.filename.contains("Test") }
        if (testArtifacts.isNotEmpty()) {
            val testResult = tools.runTests(testArtifacts)
            if (!testResult.allPassed) {
                issues.add(Issue(
                    Severity.CRITICAL,
                    "Test baÅŸarÄ±sÄ±z: ${testResult.failures.joinToString()}",
                    null
                ))
            }
        }
        
        val hasCritical = issues.any { it.severity == Severity.CRITICAL }
        
        return VerificationResult(
            passed = !hasCritical && judgeResult.score >= 0.7,
            score = judgeResult.score,
            issues = issues,
            suggestions = judgeResult.suggestions
        )
    }
}
```

---

## 6. Memory Layer â€” Episodic + Semantic HafÄ±za

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Dual Memory System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface MemoryLayer {
    /** VektÃ¶r benzerliÄŸi ile geÃ§miÅŸ episodlarÄ± bul */
    suspend fun recallSimilar(query: String, limit: Int = 5): List<Episode>
    
    /** Graf Ã¼zerinde entity/relation sorgusu */
    suspend fun queryGraph(entities: List<String>): GraphContext
    
    /** Yeni bir Ã§alÄ±ÅŸma episodunu kaydet */
    suspend fun storeEpisode(task: AgentTask, trajectory: List<AgentStep>, outcome: AgentStep.Answer)
    
    /** Semantik grafa bilgi ekle */
    suspend fun updateGraph(facts: List<Fact>)
}

class DualMemory(
    private val vectorStore: PgVectorStore,   // Episodic â€” pgvector
    private val graphStore: Neo4jClient,       // Semantic â€” Neo4j
    private val embeddingClient: EmbeddingClient
) : MemoryLayer {
    
    // â”€â”€ Episodic Memory (pgvector) â”€â”€
    // "GeÃ§en sefer RecyclerView adapter yazarken DiffUtil kullanmÄ±ÅŸtÄ±k
    //  ve review'dan 0.9 puan almÄ±ÅŸtÄ±k" â†’ benzer gÃ¶revde tekrar kullan
    
    override suspend fun recallSimilar(query: String, limit: Int): List<Episode> {
        val embedding = embeddingClient.embed(query)
        return vectorStore.query(
            """
            SELECT task_description, trajectory_summary, outcome_score, artifacts
            FROM episodes 
            ORDER BY embedding <=> $1::vector
            LIMIT $2
            """,
            embedding, limit
        ).map { it.toEpisode() }
    }
    
    override suspend fun storeEpisode(
        task: AgentTask, 
        trajectory: List<AgentStep>, 
        outcome: AgentStep.Answer
    ) {
        val summary = summarizeTrajectory(trajectory)
        val embedding = embeddingClient.embed(task.description)
        
        vectorStore.execute(
            """
            INSERT INTO episodes (task_description, trajectory_summary, 
                                  outcome_score, artifacts, embedding, created_at)
            VALUES ($1, $2, $3, $4, $5::vector, NOW())
            """,
            task.description, summary, calculateScore(outcome),
            Json.encodeToString(outcome.artifacts), embedding
        )
    }
    
    // â”€â”€ Semantic Memory (Neo4j) â”€â”€
    // "KullanÄ±cÄ± MVVM tercih ediyor, Room DB kullanÄ±yor, 
    //  min SDK 26 hedefliyor" â†’ kalÄ±cÄ± bilgi grafiÄŸi
    
    override suspend fun queryGraph(entities: List<String>): GraphContext {
        val cypher = """
            MATCH (e:Entity)-[r]->(related)
            WHERE e.name IN ${'$'}entities
            RETURN e.name, type(r), related.name, r.properties
            LIMIT 50
        """
        val records = graphStore.query(cypher, mapOf("entities" to entities))
        return GraphContext(
            facts = records.map { Fact(it["e.name"], it["type(r)"], it["related.name"]) },
            entities = entities
        )
    }
    
    override suspend fun updateGraph(facts: List<Fact>) {
        for (fact in facts) {
            graphStore.execute(
                """
                MERGE (a:Entity {name: ${'$'}subject})
                MERGE (b:Entity {name: ${'$'}object})
                MERGE (a)-[r:${fact.relation}]->(b)
                SET r.updatedAt = datetime()
                """,
                mapOf("subject" to fact.subject, "object" to fact.objectEntity)
            )
        }
    }
}

data class Episode(
    val taskDescription: String,
    val trajectorySummary: String,
    val outcomeScore: Double,
    val artifacts: List<CodeArtifact>
)

data class Fact(
    val subject: String,
    val relation: String,
    val objectEntity: String
)

data class GraphContext(
    val facts: List<Fact>,
    val entities: List<String>
)
```

---

## 7. Tool KatmanÄ± â€” GeliÅŸtirici AraÃ§larÄ±

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Tool Interface + Implementations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface Tool {
    val name: String
    val description: String
    val parameters: JsonSchema
    suspend fun execute(input: Map<String, Any>): ToolResult
}

/** Kotlin kodunu derleyip hata kontrolÃ¼ yapar */
class KotlinCompilerTool : Tool {
    override val name = "kotlin_compile"
    override val description = "Kotlin kodunu derler ve hatalarÄ± dÃ¶ndÃ¼rÃ¼r"
    override val parameters = jsonSchema { 
        property("code", JsonType.STRING, "Derlenecek Kotlin kodu")
        property("dependencies", JsonType.ARRAY, "Gradle baÄŸÄ±mlÄ±lÄ±klarÄ±")
    }
    
    override suspend fun execute(input: Map<String, Any>): ToolResult {
        val code = input["code"] as String
        // Sandbox'ta derleme (Docker container veya Kotlin Scripting API)
        val result = KotlinScriptEngine.compile(code)
        return if (result.success) {
            ToolResult.Success("Derleme baÅŸarÄ±lÄ±", result.bytecode)
        } else {
            ToolResult.Failure(result.errors.joinToString("\n"), retryable = true)
        }
    }
}

/** Dosya okuma/yazma iÅŸlemleri (sandbox iÃ§inde) */
class FileSystemTool : Tool {
    override val name = "file_system"
    override val description = "Proje dosyalarÄ±nÄ± oku, yaz, listele"
    override val parameters = jsonSchema {
        property("action", JsonType.STRING, "read | write | list | delete")
        property("path", JsonType.STRING, "Dosya yolu")
        property("content", JsonType.STRING, "YazÄ±lacak iÃ§erik (write iÃ§in)")
    }
    
    override suspend fun execute(input: Map<String, Any>): ToolResult {
        val action = input["action"] as String
        val path = (input["path"] as String).sanitizePath() // Path traversal korumasÄ±
        return when (action) {
            "read" -> ToolResult.Success(File(sandboxDir, path).readText())
            "write" -> {
                File(sandboxDir, path).apply { 
                    parentFile.mkdirs()
                    writeText(input["content"] as String) 
                }
                ToolResult.Success("Dosya yazÄ±ldÄ±: $path")
            }
            "list" -> ToolResult.Success(
                File(sandboxDir, path).walkTopDown()
                    .filter { it.isFile }
                    .joinToString("\n") { it.relativeTo(sandboxDir).path }
            )
            else -> ToolResult.Failure("Bilinmeyen aksiyon: $action", false)
        }
    }
}

/** Web'de dokÃ¼mantasyon aramasÄ± */
class WebSearchTool(private val httpClient: HttpClient) : Tool {
    override val name = "web_search"
    override val description = "Kotlin/Android dokÃ¼mantasyonu ve API referanslarÄ± ara"
    override val parameters = jsonSchema {
        property("query", JsonType.STRING, "Arama sorgusu")
    }
    
    override suspend fun execute(input: Map<String, Any>): ToolResult {
        val query = input["query"] as String
        val response = httpClient.get("https://api.tavily.com/search") {
            parameter("query", "$query Kotlin Android")
            parameter("max_results", 5)
        }
        return ToolResult.Success(response.bodyAsText())
    }
}

/** Test Ã§alÄ±ÅŸtÄ±rma (JUnit) */
class TestRunnerTool : Tool {
    override val name = "run_tests"
    override val description = "JUnit testlerini Ã§alÄ±ÅŸtÄ±r ve sonuÃ§larÄ± raporla"
    override val parameters = jsonSchema {
        property("test_code", JsonType.STRING, "Test kodu")
        property("source_code", JsonType.STRING, "Test edilecek kaynak kod")
    }
    
    override suspend fun execute(input: Map<String, Any>): ToolResult {
        // Docker sandbox'ta Gradle test Ã§alÄ±ÅŸtÄ±r
        val result = SandboxRunner.runGradleTest(
            sourceCode = input["source_code"] as String,
            testCode = input["test_code"] as String
        )
        return if (result.allPassed) {
            ToolResult.Success("âœ… ${result.passCount}/${result.totalCount} test geÃ§ti")
        } else {
            ToolResult.Failure(
                "âŒ ${result.failCount} test baÅŸarÄ±sÄ±z:\n${result.failures.joinToString("\n")}",
                retryable = true
            )
        }
    }
}
```

---

## 8. KTOR Server â€” API KatmanÄ±

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KTOR Application Setup
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fun Application.module() {
    install(ContentNegotiation) { json() }
    install(WebSockets) { pingPeriod = Duration.ofSeconds(15) }
    install(Authentication) { bearer("api-key") { /* ... */ } }
    
    val metaController = MetaController(
        agents = mapOf(
            AgentRole.PLANNER to createPlannerAgent(),
            AgentRole.CODE_WRITER to createCodeWriterAgent(),
            AgentRole.REVIEWER to createReviewerAgent(),
            AgentRole.FIXER to createFixerAgent(),
            AgentRole.TESTER to createTesterAgent(),
            AgentRole.RESEARCHER to createResearcherAgent()
        ),
        llmClient = AnthropicClient(apiKey = System.getenv("ANTHROPIC_API_KEY")),
        memory = DualMemory(pgVector, neo4j, embeddingClient)
    )
    
    routing {
        // REST endpoint â€” basit istek/cevap
        authenticate("api-key") {
            post("/api/v1/agent") {
                val request = call.receive<AgentRequest>()
                val response = metaController.process(
                    userRequest = request.message,
                    sessionId = request.sessionId
                )
                call.respond(response)
            }
        }
        
        // WebSocket â€” gerÃ§ek zamanlÄ± streaming
        authenticate("api-key") {
            webSocket("/ws/agent") {
                val sessionId = call.parameters["session"] ?: generateSessionId()
                
                for (frame in incoming) {
                    if (frame is Frame.Text) {
                        val request = Json.decodeFromString<AgentRequest>(frame.readText())
                        
                        // Streaming: her adÄ±mÄ± anÄ±nda gÃ¶nder
                        metaController.processStreaming(
                            userRequest = request.message,
                            sessionId = sessionId
                        ) { step ->
                            send(Frame.Text(Json.encodeToString(step.toStreamEvent())))
                        }
                    }
                }
            }
        }
    }
}

// Stream event modeli
@Serializable
sealed class StreamEvent {
    @Serializable data class Thinking(val thought: String) : StreamEvent()
    @Serializable data class ToolCall(val tool: String, val input: String) : StreamEvent()
    @Serializable data class ToolResult(val tool: String, val output: String) : StreamEvent()
    @Serializable data class CodeGenerated(val artifact: CodeArtifact) : StreamEvent()
    @Serializable data class PlanUpdate(val step: String, val status: String) : StreamEvent()
    @Serializable data class Done(val answer: String, val metadata: AnswerMetadata) : StreamEvent()
}
```

---

## 9. LLM Client â€” Anthropic API Entegrasyonu

```kotlin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LLM Client (Anthropic Claude)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AnthropicClient(
    private val apiKey: String,
    private val model: String = "claude-sonnet-4-5-20250929",
    private val httpClient: HttpClient = HttpClient(CIO) {
        install(ContentNegotiation) { json() }
        defaultRequest {
            header("x-api-key", apiKey)
            header("anthropic-version", "2023-06-01")
            contentType(ContentType.Application.Json)
        }
    }
) : LLMClient {
    
    override suspend fun reason(
        system: String,
        trajectory: List<AgentStep>,
        availableTools: List<String>
    ): AgentStep {
        val messages = trajectory.toAnthropicMessages()
        
        val response = httpClient.post("https://api.anthropic.com/v1/messages") {
            setBody(mapOf(
                "model" to model,
                "max_tokens" to 4096,
                "system" to system,
                "messages" to messages,
                "tools" to availableTools.map { it.toToolDefinition() }
            ))
        }
        
        val result = response.body<AnthropicResponse>()
        return result.toAgentStep()
    }
    
    override suspend fun chat(system: String, user: String): String {
        val response = httpClient.post("https://api.anthropic.com/v1/messages") {
            setBody(mapOf(
                "model" to model,
                "max_tokens" to 4096,
                "system" to system,
                "messages" to listOf(mapOf("role" to "user", "content" to user))
            ))
        }
        return response.body<AnthropicResponse>().content.first().text
    }
}
```

---

## 10. Ã–rnek AkÄ±ÅŸ: "Kotlin'de bir REST client yaz"

```
KullanÄ±cÄ±: "KTOR kullanarak GitHub API'den repo listesi Ã§eken bir client yaz"
  â”‚
  â–¼
Meta-Controller â†’ Planner Agent
  â”‚  Plan:
  â”‚  â”œâ”€ step_1: RESEARCHER â†’ "KTOR client API ve GitHub REST API araÅŸtÄ±r"
  â”‚  â”œâ”€ step_2: CODE_WRITER â†’ "GitHubClient sÄ±nÄ±fÄ±nÄ± yaz" (depends: step_1)
  â”‚  â”œâ”€ step_3: TESTER â†’ "Unit test yaz" (depends: step_2)
  â”‚  â””â”€ step_4: REVIEWER â†’ "Kodu incele" (depends: step_2, step_3)
  â”‚
  â–¼
step_1: Researcher Agent (ReAct dÃ¶ngÃ¼sÃ¼)
  â”‚  Think: "KTOR client setup ve GitHub /user/repos endpoint'ini araÅŸtÄ±rmalÄ±yÄ±m"
  â”‚  Act: web_search("KTOR HttpClient GitHub API Kotlin")
  â”‚  Observe: [KTOR docs, GitHub API docs]
  â”‚  Answer: "KTOR CIO engine + ContentNegotiation + Bearer auth gerekli"
  â”‚
  â–¼
step_2: CodeWriter Agent (ReAct + Memory)
  â”‚  [Memory'den]: "Benzer gÃ¶revde daha Ã¶nce HttpClient extension kullanmÄ±ÅŸtÄ±k â†’ 0.85 skor"
  â”‚  Think: "Extension function pattern kullanayÄ±m, data class + sealed class hata yÃ¶netimi"
  â”‚  Act: file_write â†’ GitHubClient.kt
  â”‚  Act: kotlin_compile â†’ Derleme kontrolÃ¼
  â”‚  Answer: GitHubClient.kt + GitHubModels.kt
  â”‚
  â–¼
step_3: Tester Agent
  â”‚  Act: file_write â†’ GitHubClientTest.kt (MockEngine ile)
  â”‚  Act: run_tests â†’ 5/5 geÃ§ti âœ…
  â”‚
  â–¼
step_4: Reviewer Agent + Verification Gate
  â”‚  LLM-as-Judge: 0.88 skor
  â”‚  Issues: [WARNING: "Rate limiting eksik"]
  â”‚  â†’ FIXER Agent â†’ Rate limiter eklendi
  â”‚  â†’ Re-verify: 0.95 skor âœ…
  â”‚
  â–¼
SonuÃ§ â†’ KullanÄ±cÄ±ya stream edilir
```

---

## 11. Proje YapÄ±sÄ±

```
agent-backend/
â”œâ”€â”€ build.gradle.kts
â”œâ”€â”€ src/main/kotlin/
â”‚   â”œâ”€â”€ Application.kt              â† KTOR setup
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ AgentStep.kt            â† Sealed class state machine
â”‚   â”‚   â”œâ”€â”€ ReActAgent.kt           â† Tek ajan Ã§ekirdeÄŸi
â”‚   â”‚   â”œâ”€â”€ MetaController.kt       â† Multi-agent orchestrator
â”‚   â”‚   â””â”€â”€ VerificationGate.kt     â† PEV doÄŸrulama
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ PlannerAgent.kt
â”‚   â”‚   â”œâ”€â”€ CodeWriterAgent.kt
â”‚   â”‚   â”œâ”€â”€ ReviewerAgent.kt
â”‚   â”‚   â”œâ”€â”€ FixerAgent.kt
â”‚   â”‚   â”œâ”€â”€ TesterAgent.kt
â”‚   â”‚   â””â”€â”€ ResearcherAgent.kt
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ Tool.kt                 â† Tool interface
â”‚   â”‚   â”œâ”€â”€ KotlinCompilerTool.kt
â”‚   â”‚   â”œâ”€â”€ FileSystemTool.kt
â”‚   â”‚   â”œâ”€â”€ WebSearchTool.kt
â”‚   â”‚   â””â”€â”€ TestRunnerTool.kt
â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â”œâ”€â”€ MemoryLayer.kt          â† Interface
â”‚   â”‚   â”œâ”€â”€ DualMemory.kt           â† pgvector + Neo4j impl
â”‚   â”‚   â”œâ”€â”€ PgVectorStore.kt
â”‚   â”‚   â””â”€â”€ Neo4jClient.kt
â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”œâ”€â”€ LLMClient.kt            â† Interface
â”‚   â”‚   â””â”€â”€ AnthropicClient.kt      â† Claude API impl
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ AgentRequest.kt
â”‚   â”‚   â”œâ”€â”€ AgentResponse.kt
â”‚   â”‚   â”œâ”€â”€ ExecutionPlan.kt
â”‚   â”‚   â””â”€â”€ StreamEvent.kt
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ AgentRoutes.kt
â”‚       â””â”€â”€ WebSocketRoutes.kt
â”œâ”€â”€ src/test/kotlin/
â”‚   â””â”€â”€ ...
â””â”€â”€ docker/
    â”œâ”€â”€ docker-compose.yml           â† PostgreSQL + Neo4j + App
    â””â”€â”€ sandbox/
        â””â”€â”€ Dockerfile               â† Kod Ã§alÄ±ÅŸtÄ±rma sandbox'u
```

---

## 12. BaÄŸÄ±mlÄ±lÄ±klar (build.gradle.kts)

```kotlin
dependencies {
    // KTOR Server
    implementation("io.ktor:ktor-server-core:2.3.+")
    implementation("io.ktor:ktor-server-netty:2.3.+")
    implementation("io.ktor:ktor-server-websockets:2.3.+")
    implementation("io.ktor:ktor-server-content-negotiation:2.3.+")
    implementation("io.ktor:ktor-server-auth:2.3.+")
    implementation("io.ktor:ktor-serialization-kotlinx-json:2.3.+")
    
    // KTOR Client (LLM API Ã§aÄŸrÄ±larÄ± iÃ§in)
    implementation("io.ktor:ktor-client-core:2.3.+")
    implementation("io.ktor:ktor-client-cio:2.3.+")
    implementation("io.ktor:ktor-client-content-negotiation:2.3.+")
    
    // Database
    implementation("org.postgresql:postgresql:42.7.+")
    implementation("com.pgvector:pgvector:0.1.+")          // Episodic memory
    implementation("org.neo4j.driver:neo4j-java-driver:5.+") // Semantic memory
    
    // Serialization
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.+")
    
    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.+")
    
    // Kotlin Scripting (sandbox compile)
    implementation("org.jetbrains.kotlin:kotlin-scripting-jsr223:1.9.+")
    
    // Test
    testImplementation("io.ktor:ktor-server-test-host:2.3.+")
    testImplementation("org.jetbrains.kotlin:kotlin-test:1.9.+")
}
```

---

## 13. Uygulama Yol HaritasÄ±

| Hafta | Milestone | Tamamlanacak BileÅŸenler |
|-------|-----------|------------------------|
| **1-2** | ğŸŸ¢ ReAct Ã‡ekirdeÄŸi | `AgentStep` sealed class, `ReActAgent`, `AnthropicClient`, basit bir tool (file_system) |
| **3** | ğŸŸ¡ Tool Layer | `KotlinCompilerTool`, `WebSearchTool`, `TestRunnerTool` |
| **4-5** | ğŸŸ  Multi-Agent | `MetaController`, Planner/CodeWriter/Reviewer ajanlarÄ±, streaming WebSocket |
| **6** | ğŸ”´ PEV | `VerificationGate`, LLM-as-Judge, Fixer dÃ¶ngÃ¼sÃ¼ |
| **7-8** | ğŸŸ£ Memory | pgvector episodic store, Neo4j semantic graph, hafÄ±za entegrasyonu |
| **9-10** | âš« Production | Docker compose, rate limiting, observability (OpenTelemetry), load test |

---

## 14. Kritik TasarÄ±m KararlarÄ±

**Neden LangGraph deÄŸil, kendi state machine?**
Kotlin'in `sealed class` + `when` + `coroutines` Ã¼Ã§lÃ¼sÃ¼, LangGraph'Ä±n yaptÄ±ÄŸÄ± her ÅŸeyi type-safe ve compile-time checked olarak yapmanÄ± saÄŸlÄ±yor. Python'da runtime'da keÅŸfettiÄŸin hatalarÄ± Kotlin'de derleme aÅŸamasÄ±nda yakalarsÄ±n.

**Neden pgvector + Neo4j (iki DB)?**
Episodic memory (geÃ§miÅŸ konuÅŸmalar) vektÃ¶r benzerliÄŸi gerektirir â†’ pgvector yeterli. Semantic memory (entity-relation bilgisi) graf traversal gerektirir â†’ Neo4j doÄŸal fit. Tek DB ile ikisini de yapmaya Ã§alÄ±ÅŸmak her zaman compromise olur.

**Neden Anthropic Claude?**
Function calling (tool use) desteÄŸi native, Kotlin JSON serialization ile doÄŸrudan uyumlu. Structured output garantisi, ajan gÃ¼venilirliÄŸi iÃ§in kritik.

**Sandbox neden Ã¶nemli?**
Ajan Ã¼rettiÄŸi kodu Ã§alÄ±ÅŸtÄ±rabilmeli (compile, test). Bu kod gÃ¼venilmez â†’ Docker container iÃ§inde izole sandbox ÅŸart. Host sisteme eriÅŸim kesinlikle yok.